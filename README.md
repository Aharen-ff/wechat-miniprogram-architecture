# 设计说明

Created: Dec 4, 2020 10:23 PM

## 结构

- `apis`
    - 存放接口定义文件
- `assets`
    - 存放静态资源文件
    - 一般包括 `icons` `images` 等
- `classes`
    - 类的定义
    - 使用面向对象来处理部分核心的、复杂的业务
- `components`
    - 公用组件
    - 设计时应尽可能剥离具体业务
- `configs`
    - 配置文件
- `packages`
    - 小程序分包
    - 可以将不同的模块以分包的形式编写，达到灵活外挂的目的
    - 每个分包可以有自己的 `assets` `classes` `components`
    - 不适合单独分包的几种情况：业务非常简单；页面非常少；与某个模块高度耦合。
- `pages`
    - 小程序主包，上述不适合单独分包的部分功能
    - 主包直接使用根目录的 `assets` `classes` 等
    - 每个功能模块使用一个文件夹隔离
- `styles`
    - 样式文件
- `utils`
    - 工具方法，数据模型，权限配置等

## 函数（方法）

- 函数应具备单一职责
    - 如果一个函数无法在命名上概括其功能，考虑将其拆分
    - 一个函数可以概括整个流程，但是流程内每个环节需要拆分
        - 例：提交是一个完整流程，但校验需要拆分成单独的校验函数
    - 简单判断：如果一个函数超过 200 行，一般情况下存在拆分可能
- 功能的实现应该简洁
    - 充分考虑不同情况，在更高维度尝试统一
    - 避免无意义的判断和嵌套
        - 示例：

            ```jsx
            function bad(condition = true, anotherCondition = false) {
            	if (condition === true) {
            		if (anotherCondition === true) {
            			// do something
            		}
            	}
            }

            function better(condition = true, anotherCondition = false) {
            	if (!condition || !anotherCondition) return;
            	// do something
            }
            ```

- 尽可能纯
    - 定义： [https://zh.wikipedia.org/wiki/纯函数](https://zh.wikipedia.org/wiki/%E7%BA%AF%E5%87%BD%E6%95%B0)

## 面向对象

- **以下内容可能会存在争议**
- 在原生小程序中使用面向对象并不舒服，但对代码维护有相当大的提升
- 只在业务上有明显的派生关系，且复杂度较高的地方使用面向对象
- 避免使用私有成员，除非类属性很少且不需要与界面产生互动

## 组件设计

- 组件应具备单一职责
- 避免出现超过三层的组件嵌套，这会导致数据流通变得更复杂
    - 避免： `page` → `CompParent` → `CompChild` → `Component` → `AnotherComponent`
    - 如果出现了这种情况，可以考虑使用 slot 等方式消除部分中间层
        - 示例： `page` → `CompChild` `CompChildTwo` `Component` → `AnotherComponent`
- 遵循数据单向流动原则
    - 子组件对数据进行操作后，向父组件发送事件，携带操作结果
    - 父组件接收事件，根据操作结果更改数据
    - 更改后的数据通过 Properties 的方式传递给子组件，完成数据更新
    - 如果组件有多层嵌套，则操作结果会层层向上传递，在祖先组件更改数据后，再层层向下传给子孙组件
        - 这是避免组件多层嵌套的直接原因，数据流动范围太大
        - 视项目大小，可以使用观察者模式，利用全局的 EventBus 来让子孙组件直接通知祖先组件，解决层层传递的问题
- 最小数据交互
    - 只接收组件需要的数据
        - 例： `ListItem` 组件只接收列表中一项的数据，而不是整个列表以及下标
    - 只传递基本事件信息
        - 例： `EditorUser` 和 `EditorProduct` 两个组件进行编辑操作后，向父组件发送的事件都是 `on-edit`，由父组件在监听时作区分。不需要在事件传递时区分为 `on-user-edit` 和 `on-product-edit`
    - 只暴露有限的配置项
        - 不需要把组件的方方面面都设计成可配置的，避免使用时产生困扰
- 可组装
    - 例：组件只关心内部的样式，容器样式（边距等）由父组件决定，方便与其他组件组装

## 模块设计

- 注：没有特别说明的情况下，模块指的是一个完整的业务流程，是若干子模块的集合体
- 一个完整的业务流程定义了一个模块
- 一个模块可以作为一个分包
    - 分包可以延迟加载，提高小程序启动速度
    - 分包可以良好地隔离代码，避免互相影响
    - 分包可以拥有独立的 `components` `utils` 等，方便局部复用
- 模块之间是平级的
    - 采用扁平化的文件组织形式，忽略业务逻辑上的包含关系
    - 扁平化可以赋予更高的自由度，同时方便维护
- 借助组件来实现模块层面的复用
    - 不同模块中包含类似功能时，如果该功能无法独立作为一个模块，可以考虑将具体实现抽取成公用组件，各模块的页面只作容器

## 路由

- 自定义一份路由和路径的映射关系
- 将微信原生的页面跳转方法做一层封装，挂载到全局
- 这样可以将跳转动作和跳转路径解耦，对于使用者而言，不再需要关心跳转的具体路径

## 跨项目复用

- 建议在组件层和方法层进行复用，避免模块复用
    - 组件以最小功能单一职责为标准进行设计，保证良好的组装性
    - 共用的数据处理过程抽取成纯函数调用
